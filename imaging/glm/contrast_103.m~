function contrast_101(subj,session)

root            = '/data/pt_02071/choice-maps/imagingData/sub-';
nblocks         = 3;

% Name of the experimental design. Start with 2* for RSA-designs and 1* for
% more basic designs


design_name     = '101';

factorial_design.dir = {[root,num2str(subj),'/ses-',num2str(session),'/1stLevel/design_',design_name]};
cd(factorial_design.dir{1})

load('SPM.mat');


% how many columns needed for which condition
% ====================================================================== %

col.sess        = nblocks;              % one constant per block
col.motion      = 17;     % motion only %% 6 motion regressors per session and 17 physio regressors
col.cond        = length(SPM.Sess(1).col)-col.motion;

col.general     = zeros(1,col.cond);  % condition only
col.total.all   = nblocks*(col.cond+col.motion) + col.sess;
col.block       = repmat([col.general zeros(1,col.motion)],col.sess,1);

% all columns together
% ====================================================================== %

disp(['Design matrix should have ',num2str(col.total.all),' columns']);

concounter = 1;

% % ADAPTATION
% ====================================================================== %
col.names = [];
counter = 0;
for i = 1:size(SPM.Sess(1).U,2)
    for j = 1:size(SPM.Sess(1).U(i).name,2)
        counter = counter + 1;
        col.names{counter} = [num2str(counter), '  -  ', SPM.Sess(1).U(i).name{j}];
        disp([num2str(counter), '  -  ', SPM.Sess(1).U(i).name{j}]);
    end
end



% 1. Object Onset
ci_pos = 1:4:16;
block = col.block;
for i = 1:nblocks
    block(i,ci_pos) = 1;
end
stim_onset = [reshape(block',1,length(block)*nblocks) zeros(1,nblocks)];
stats.con.consess{concounter}.tcon.name      = 'allOnset'; %name
stats.con.consess{concounter}.tcon.convec    = stim_onset;                   %contrast vector
stats.con.consess{concounter}.tcon.sessrep   = 'none';                   %replicate vector over sessions
concounter = concounter+1;


% 2. button
ci_pos = []; for i = 1:length(col.names), if strfind(col.names{i},"button"), ci_pos = [ci_pos i]; end, end
block = col.block;
for i = 1:nblocks
    block(i,ci_pos) = 1;
end
button = [reshape(block',1,length(block)*nblocks) zeros(1,nblocks)];
stats.con.consess{concounter}.tcon.name      = 'button'; %name
stats.con.consess{concounter}.tcon.convec    = button;                   %contrast vector
stats.con.consess{concounter}.tcon.sessrep   = 'none';                   %replicate vector over sessions
concounter = concounter+1;


% 3. Switch versus stay trials
ci_pos = [3 7];
ci_neg = [1 5];
block = col.block;
for i = 1:nblocks
    block(i,ci_pos) = 1;
    block(i,ci_neg) = -1;
end
stayswitch = [reshape(block',1,length(block)*nblocks) zeros(1,nblocks)];
stats.con.consess{concounter}.tcon.name      = 'stayswitch'; %name
stats.con.consess{concounter}.tcon.convec    = stayswitch;                   %contrast vector
stats.con.consess{concounter}.tcon.sessrep   = 'none';                   %replicate vector over sessions
concounter = concounter+1;


% 4. Distance
ci_pos = []; for i = 1:length(col.names), if strfind(col.names{i},"xdistance"), ci_pos = [ci_pos i]; end, end
block = col.block;
for i = 1:nblocks
    block(i,ci_pos) = 1;
end
distance = [reshape(block',1,length(block)*nblocks) zeros(1,nblocks)];
stats.con.consess{concounter}.tcon.name      = 'allDistance'; %name
stats.con.consess{concounter}.tcon.convec    = distance;                   %contrast vector
stats.con.consess{concounter}.tcon.sessrep   = 'none';                   %replicate vector over sessions
concounter = concounter+1;


% 5. stay distance
ci_pos = []; for i = 1:length(col.names), if strfind(col.names{i},"stayxdistance"), ci_pos = [ci_pos i]; end, end
block = col.block;
for i = 1:nblocks
    block(i,ci_pos) = 1;
end
stayDistance = [reshape(block',1,length(block)*nblocks) zeros(1,nblocks)];
stats.con.consess{concounter}.tcon.name      = 'stayDistance'; %name
stats.con.consess{concounter}.tcon.convec    = stayDistance;                   %contrast vector
stats.con.consess{concounter}.tcon.sessrep   = 'none';                   %replicate vector over sessions
concounter = concounter+1;


% 6. switch distance
ci_pos = []; for i = 1:length(col.names), if strfind(col.names{i},"switchxdistance"), ci_pos = [ci_pos i]; end, end
block = col.block;
for i = 1:nblocks
    block(i,ci_pos) = 1;
end
switchDistance = [reshape(block',1,length(block)*nblocks) zeros(1,nblocks)];
stats.con.consess{concounter}.tcon.name      = 'switchDistance'; %name
stats.con.consess{concounter}.tcon.convec    = switchDistance;                   %contrast vector
stats.con.consess{concounter}.tcon.sessrep   = 'none';                   %replicate vector over sessions
concounter = concounter+1;

% 7. stay distance versus switch distance
ci_pos = []; for i = 1:length(col.names), if strfind(col.names{i},"switchxdistance"), ci_pos = [ci_pos i]; end, end
ci_neg = []; for i = 1:length(col.names), if strfind(col.names{i},"stayxdistance"), ci_neg = [ci_neg i]; end, end
block = col.block;
for i = 1:nblocks
    block(i,ci_pos) = 1;
    block(i,ci_neg) = -1;
end
stayswitchdistance = [reshape(block',1,length(block)*nblocks) zeros(1,nblocks)];
stats.con.consess{concounter}.tcon.name      = 'staySwitchDistance'; %name
stats.con.consess{concounter}.tcon.convec    = stayswitchdistance;                   %contrast vector
stats.con.consess{concounter}.tcon.sessrep   = 'none';                   %replicate vector over sessions
concounter = concounter+1;


% 9. choiceOnset
ci_pos = 9;
if session == 3, ci_pos = [17 24]; end
block = col.block;
for i = 1:nblocks
    block(i,ci_pos) = 1;
end
choice = [reshape(block',1,length(block)*nblocks) zeros(1,nblocks)];
stats.con.consess{concounter}.tcon.name      = 'choiceOnset'; %name
stats.con.consess{concounter}.tcon.convec    = choice;                   %contrast vector
stats.con.consess{concounter}.tcon.sessrep   = 'none';                   %replicate vector over sessions
concounter = concounter+1;

tt = "d"; 

for t = 1:size(tt,2)
    
    % 10. chosen distance
    ci_pos = []; for i = 1:length(col.names), if strfind(col.names{i},['xchosen distance ' tt{t}]), ci_pos = [ci_pos i]; end, end
    block = col.block;
    for i = 1:nblocks
        block(i,ci_pos) = 1;
    end
    chosenDist = [reshape(block',1,length(block)*nblocks) zeros(1,nblocks)];
    stats.con.consess{concounter}.tcon.name      = [tt{t}, ' chosenDist']; %name
    stats.con.consess{concounter}.tcon.convec    = chosenDist;                   %contrast vector
    stats.con.consess{concounter}.tcon.sessrep   = 'none';                   %replicate vector over sessions
    concounter = concounter+1;
    
    
    % 11. unchosen distance
    ci_pos = []; for i = 1:length(col.names), if strfind(col.names{i},['xunchosen distance ' tt{t}]), ci_pos = [ci_pos i]; end, end
    block = col.block;
    for i = 1:nblocks
        block(i,ci_pos) = 1;
    end
    unchosenDist = [reshape(block',1,length(block)*nblocks) zeros(1,nblocks)];
    stats.con.consess{concounter}.tcon.name      = [tt{t}, ' unchosenDist']; %name
    stats.con.consess{concounter}.tcon.convec    = unchosenDist;                   %contrast vector
    stats.con.consess{concounter}.tcon.sessrep   = 'none';                   %replicate vector over sessions
    concounter = concounter+1;
    
    
    % 12. chosen - unchosen distance
    ci_pos = []; for i = 1:length(col.names), if strfind(col.names{i},['xchosen distance ' tt{t}]), ci_pos = [ci_pos i]; end, end
    ci_neg = []; for i = 1:length(col.names), if strfind(col.names{i},['xunchosen distance ' tt{t}]), ci_neg = [ci_neg i]; end, end
    block = col.block;
    for i = 1:nblocks
        block(i,ci_pos) = 1;
        block(i,ci_neg) = -1;
    end
    chosen_unchosenDist = [reshape(block',1,length(block)*nblocks) zeros(1,nblocks)];
    stats.con.consess{concounter}.tcon.name      = [tt{t}, ' chosen_unchosenDist']; %name
    stats.con.consess{concounter}.tcon.convec    = chosen_unchosenDist;                   %contrast vector
    stats.con.consess{concounter}.tcon.sessrep   = 'none';                   %replicate vector over sessions
    concounter = concounter+1;
    
    % 12. chosen + unchosen distance
    ci_pos = []; for i = 1:length(col.names), if strfind(col.names{i},['xchosen distance ' tt{t}]), ci_pos = [ci_pos i]; end, end
    for i = 1:length(col.names), if strfind(col.names{i},['xunchosen distance ' tt{t}]), ci_pos = [ci_pos i]; end, end
    block = col.block;
    for i = 1:nblocks
        block(i,ci_pos) = 1;
    end
    chosenunchosenDist = [reshape(block',1,length(block)*nblocks) zeros(1,nblocks)];
    stats.con.consess{concounter}.tcon.name      = [tt{t}, ' chosenplusunchosenDist']; %name
    stats.con.consess{concounter}.tcon.convec    = chosenunchosenDist;                   %contrast vector
    stats.con.consess{concounter}.tcon.sessrep   = 'none';                   %replicate vector over sessions
    concounter = concounter+1;
    
    
   
    
    
    % 18. chosen + unchosen value counterfactual
    ci_pos = []; for i = 1:length(col.names), if strfind(col.names{i},['xcounterfactual chosen value ' tt{t}]), ci_pos = [ci_pos i]; end, end
    for i = 1:length(col.names), if strfind(col.names{i},['xcounterfactual unchosen value ' tt{t}]), ci_pos = [ci_pos i]; end, end
    block = col.block;
    for i = 1:nblocks
        block(i,ci_pos) = 1;
    end
    chosenplusunchosenCounterValue = [reshape(block',1,length(block)*nblocks) zeros(1,nblocks)];
    stats.con.consess{concounter}.tcon.name      = [tt{t}, ' chosenplusunchosenCounterValue']; %name
    stats.con.consess{concounter}.tcon.convec    = chosenplusunchosenCounterValue;                   %contrast vector
    stats.con.consess{concounter}.tcon.sessrep   = 'none';                   %replicate vector over sessions
    concounter = concounter+1;
    
end





%%
stats.con.spmmat                    = {[factorial_design.dir{1},'/SPM.mat']}; % where to find SPM.mat on which estimation has already run

% show in results window
% ====================================================================== %

stats.results.spmmat                = {[factorial_design.dir{1},'/SPM.mat']}; %which SPM.mat
stats.results.conspec.titlestr      = '';   %whith title
stats.results.conspec.contrasts     = 1;    %which contrast
stats.results.conspec.threshdesc    = 'none'; %FWD or none
stats.results.conspec.thresh        = 0.05; %threshold
stats.results.conspec.extent        = 0;    %cluster extend
stats.results.conspec.mask          = struct('contrasts', {}, 'thresh', {}, 'mtype', {});
stats.results.units                 = 1;    %datatype:volumetric
stats.con.delete                    = 1;    %delete existing contrasts
stats.results.print                 = true; %print in results window

matlabbatch{1}.spm.stats = stats;
contrast = matlabbatch;
save([factorial_design.dir{1},'/contrast.mat'],'contrast');
save([factorial_design.dir{1},'/contrastmatrix.mat'],'contrast');

spm_jobman('run',matlabbatch);

clear matlabbatch;


%% Smooth contrast images

clear matlabbatch
mkdir ([factorial_design.dir{1},'/smooth/warp'])

% specify scans for each session and voxel shift map generated in
% previous step (vdm*)
images  = spm_select('List','con*nii');
for epi = 1:size(images,1)
    matlabbatch{1}.spm.spatial.smooth.data{epi,1} = fullfile(factorial_design.dir{1},images(epi,:));
end

matlabbatch{1}.spm.spatial.smooth.fwhm = [6 6 6];
matlabbatch{1}.spm.spatial.smooth.dtype = 0;
matlabbatch{1}.spm.spatial.smooth.im = 0;
matlabbatch{1}.spm.spatial.smooth.prefix = 's_';

spm_jobman('run',matlabbatch);

images  = spm_select('List','spmT*nii');
for epi = 1:size(images,1)
    matlabbatch{1}.spm.spatial.smooth.data{epi,1} = fullfile(factorial_design.dir{1},images(epi,:));
end
spm_jobman('run',matlabbatch);

images  = spm_select('List','s_*nii');
for i = 1:length(images)
    movefile(deblank(images(i,:)),['smooth/',deblank(images(i,:))])
end




spm_jobman('run',matlabbatch);
movefile('s_*',[factorial_design.dir{1},'/smooth/'])
delete([factorial_design.dir{1},'/smooth/s_s_*'])
